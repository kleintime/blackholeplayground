<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Black Hole Playground — Single File</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #000;
      --fg: #eaeaea;
      --muted: #a0a0a0;
      --panel: rgba(255,255,255,0.06);
      --panel-border: rgba(255,255,255,0.12);
      --btn: rgba(255,255,255,0.1);
      --btn-hover: rgba(255,255,255,0.18);
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; background: var(--bg); color: var(--fg);
      font: 14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 24px; margin: 0 0 8px 0; }
    p.sub { margin: 0 0 16px 0; color: var(--muted); }
    .card { border: 1px solid var(--panel-border); border-radius: 16px; overflow: hidden; background: var(--panel); }
    canvas { display: block; width: 100%; height: auto; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 12px; margin-top: 14px; }
    .control { background: var(--panel); border: 1px solid var(--panel-border); border-radius: 12px; padding: 10px; }
    .label { font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    .row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    button { background: var(--btn); color: var(--fg); border: 1px solid var(--panel-border); padding: 8px 12px; border-radius: 10px; cursor: pointer; }
    button:hover { background: var(--btn-hover); }
    .foot { color: var(--muted); font-size: 12px; margin-top: 14px; }
    .small { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .tog { display: flex; align-items: center; gap: 8px; }
    input[type="range"] { width: 100%; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Black Hole Playground</h1>
    <p class="sub">
      A fast, interactive sketch of a spinning black hole with an accretion disk.
      Use the sliders to change <b>mass</b>, <b>spin</b>, brightness, speed, and the viewing angle.
      The thin bright ring is the <i>photon ring</i>; the dashed inner ring marks the <i>event horizon</i>.
      This is an artistically credible approximation (not a GR ray tracer).
    </p>

    <div class="card">
      <canvas id="view" width="1000" height="640"></canvas>
    </div>

    <div class="grid">
      <div class="control">
        <div class="label" id="labMass">Mass (visual Rₛ)</div>
        <input id="mass" type="range" min="1" max="12" step="0.1" value="5" />
      </div>
      <div class="control">
        <div class="label" id="labSpin">Spin (dimensionless a*)</div>
        <input id="spin" type="range" min="0" max="0.99" step="0.01" value="0.6" />
      </div>
      <div class="control">
        <div class="label" id="labBright">Accretion disk brightness</div>
        <input id="bright" type="range" min="0" max="1" step="0.01" value="0.85" />
      </div>
      <div class="control">
        <div class="label" id="labSpeed">Disk angular speed</div>
        <input id="speed" type="range" min="0" max="1" step="0.01" value="0.5" />
      </div>
      <div class="control">
        <div class="label" id="labInc">View inclination (deg)</div>
        <input id="inc" type="range" min="0" max="89" step="1" value="65" />
      </div>
      <div class="control row">
        <button id="toggle">{play}</button>
        <button id="reset">Reset</button>
        <label class="tog"><input type="checkbox" id="guides" checked> Show guides</label>
        <label class="tog"><input type="checkbox" id="stars" checked> Starfield</label>
      </div>
    </div>

    <div class="foot">
      ⚠️ <span class="small">Physics note:</span> We hint at real effects (Schwarzschild radius, photon ring, relativistic beaming/Doppler boosting) using lightweight approximations for speed.
    </div>
  </div>

<script>
(() => {
  const TAU = Math.PI * 2;
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b - a) * t;
  const hsla = (h,s,l,a=1)=>`hsla(${h}, ${s}%, ${l}%, ${a})`;

  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');
  let w = canvas.width, h = canvas.height;

  // State
  const state = {
    paused: false,
    mass: 5,
    spin: 0.6,
    bright: 0.85,
    speed: 0.5,
    incDeg: 65,
    guides: true,
    stars: true,
    t: 0
  };

  // UI Elements
  const E = id => document.getElementById(id);
  const labMass = E('labMass');
  const labSpin = E('labSpin');
  const labBright = E('labBright');
  const labSpeed = E('labSpeed');
  const labInc = E('labInc');

  function syncLabels() {
    labMass.textContent  = `Mass (visual Rₛ): ${state.mass.toFixed(1)}×`;
    labSpin.textContent  = `Spin (dimensionless a*): ${state.spin.toFixed(2)}`;
    labBright.textContent= `Accretion disk brightness: ${(state.bright*100)|0}%`;
    labSpeed.textContent = `Disk angular speed: ${(state.speed*100)|0}%`;
    labInc.textContent   = `View inclination (deg): ${state.incDeg}`;
    E('toggle').textContent = state.paused ? 'Play' : 'Pause';
  }

  E('mass').addEventListener('input', e => { state.mass=parseFloat(e.target.value); syncLabels(); });
  E('spin').addEventListener('input', e => { state.spin=parseFloat(e.target.value); syncLabels(); });
  E('bright').addEventListener('input', e => { state.bright=parseFloat(e.target.value); syncLabels(); });
  E('speed').addEventListener('input', e => { state.speed=parseFloat(e.target.value); syncLabels(); });
  E('inc').addEventListener('input', e => { state.incDeg=parseInt(e.target.value,10); syncLabels(); });
  E('guides').addEventListener('change', e => state.guides = e.target.checked);
  E('stars').addEventListener('change', e => state.stars = e.target.checked);
  E('toggle').addEventListener('click', () => { state.paused = !state.paused; syncLabels(); });
  E('reset').addEventListener('click', () => {
    Object.assign(state, { mass:5, spin:0.6, bright:0.85, speed:0.5, incDeg:65, guides:true, stars:true });
    E('mass').value = state.mass;
    E('spin').value = state.spin;
    E('bright').value = state.bright;
    E('speed').value = state.speed;
    E('inc').value = state.incDeg;
    E('guides').checked = state.guides;
    E('stars').checked = state.stars;
    syncLabels();
  });
  syncLabels();

  // Build star field deterministically
  function buildStars(seed, count, w, h) {
    const stars = [];
    let x = seed | 0;
    const rand = () => (x = (x * 1664525 + 1013904223) >>> 0) / 4294967296;
    for (let i = 0; i < count; i++) {
      stars.push({ x: rand() * w, y: rand() * h, r: rand() * 1.2 + 0.3, a: rand() * 0.6 + 0.4 });
    }
    return stars;
  }
  const stars = buildStars(42, 800, w, h);

  // Draw loop
  let raf;
  function draw() {
    if (!state.paused) state.t += 0.016 * (0.5 + state.speed * 1.5);
    const t = state.t;

    // Background gradient
    const g = ctx.createRadialGradient(w*0.5, h*0.5, 10, w*0.5, h*0.5, Math.max(w,h)*0.7);
    g.addColorStop(0, '#03030a'); g.addColorStop(1, '#000');
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

    // Stars
    if (state.stars) {
      ctx.save();
      for (const s of stars) {
        ctx.globalAlpha = s.a;
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, TAU); ctx.fill();
      }
      ctx.restore();
    }

    // Center + scales
    const cx = w * 0.5, cy = h * 0.5;
    const Rs = 20 + state.mass * 10;                 // Schwarzschild radius (visual)
    const photonRing = Rs * (1.5 + 0.6 * (1 - state.spin));
    const inc = state.incDeg * Math.PI / 180;
    const diskInner = Rs * (1.2 - 0.5 * state.spin);
    const diskOuter = Rs * 4.2;

    // Lens bloom
    ctx.save();
    const bloom = ctx.createRadialGradient(cx, cy, Rs*0.9, cx, cy, photonRing*1.4);
    bloom.addColorStop(0, 'rgba(0,0,0,0)');
    bloom.addColorStop(0.65, 'rgba(255,255,255,0.03)');
    bloom.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = bloom;
    ctx.beginPath(); ctx.arc(cx, cy, photonRing*1.5, 0, TAU); ctx.fill();
    ctx.restore();

    // Accretion disk (elliptical rings + Doppler/beaming tint)
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(0.2 * Math.sin(t * 0.1));
    const cosInc = Math.cos(inc);

    const steps = 240, rings = 18;
    for (let i = 0; i < steps; i++) {
      const a0 = (i / steps) * TAU;
      const a1 = ((i + 1) / steps) * TAU;
      for (let j = 0; j < rings; j++) {
        const r0 = lerp(diskInner, diskOuter, j / rings);
        const r1 = lerp(diskInner, diskOuter, (j + 1) / rings);

        const x0 = r0 * Math.cos(a0), y0 = r0 * Math.sin(a0) * cosInc;
        const x1 = r1 * Math.cos(a0), y1 = r1 * Math.sin(a0) * cosInc;
        const x2 = r1 * Math.cos(a1), y2 = r1 * Math.sin(a1) * cosInc;
        const x3 = r0 * Math.cos(a1), y3 = r0 * Math.sin(a1) * cosInc;

        const beta = clamp(0.35 + 0.35 * (1 - j / rings) + state.spin * 0.2, 0, 0.88);
        const viewCos = Math.cos(a0 - t * (1.2 + state.spin * 0.8));
        const doppler = (1 + beta * viewCos) / Math.sqrt(1 - beta * beta);
        const heat = 1 - j / rings;

        const blueHue = 210, redHue = 10, baseHue = 45;
        const hue = doppler > 1
          ? lerp(baseHue, blueHue, clamp((doppler - 1) * 1.6, 0, 1))
          : lerp(baseHue, redHue,  clamp((1 - doppler) * 1.6, 0, 1));
        const alpha = 0.06 + 0.7 * state.bright * heat;

        ctx.fillStyle = hsla(hue, 90, 55 - 20 * (1 - heat), alpha);
        ctx.beginPath();
        ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3);
        ctx.closePath(); ctx.fill();
      }
    }
    ctx.restore();

    // Photon ring
    ctx.save();
    ctx.strokeStyle = `rgba(255,255,255,${0.25 + 0.35 * (1 - state.spin)})`;
    ctx.lineWidth = Math.max(1, Rs * 0.05);
    ctx.beginPath(); ctx.arc(cx, cy, photonRing, 0, TAU); ctx.stroke();
    ctx.restore();

    // Event horizon
    ctx.save();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(cx, cy, Rs, 0, TAU); ctx.fill();
    const eg = ctx.createRadialGradient(cx, cy, Rs*0.95, cx, cy, Rs*1.35);
    eg.addColorStop(0, 'rgba(255,255,255,0)');
    eg.addColorStop(1, 'rgba(255,255,255,0.08)');
    ctx.fillStyle = eg; ctx.beginPath(); ctx.arc(cx, cy, Rs*1.35, 0, TAU); ctx.fill();
    ctx.restore();

    // Guides
    if (state.guides) {
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.setLineDash([4,6]);
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(cx, cy, Rs, 0, TAU); ctx.stroke();
      ctx.beginPath(); ctx.arc(cx, cy, photonRing, 0, TAU); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.65)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, monospace';
      ctx.fillText('Event Horizon (Rₛ)', cx + Rs + 8, cy - 6);
      ctx.fillText('Photon Ring (~1.5 Rₛ)', cx + photonRing + 8, cy + 14);
      ctx.restore();
    }

    raf = requestAnimationFrame(draw);
  }
  draw();

  // Handle resize (keep aspect by adjusting CSS only)
  const ro = new ResizeObserver(() => {
    // We keep the drawing buffer constant for speed; CSS scales visually.
  });
  ro.observe(canvas);
})();
</script>
</body>
</html>
